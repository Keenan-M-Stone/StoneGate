commit 532979416dce740cac04144f4ee547a656a14a96
Author: Keenan-M-Stone <lemma137@gmail.com>
Date:   Thu Nov 13 21:17:16 2025 -0500

    Implement undo/redo

diff --git a/backend/src/backend/demo.cpp b/backend/src/backend/demo.cpp
index 8352e0e..e12053b 100644
--- a/backend/src/backend/demo.cpp
+++ b/backend/src/backend/demo.cpp
@@ -1,3 +1,9 @@
+/*
+src/backend/demo.cpp
+This is intended to simulate instrument behavior, including
+artificial noise and mimic and the qualities of the individual
+parts and devices connected to the apparatus.
+*/
 #include "backend/demo.h"
 #include <chrono>
 
diff --git a/backend/src/backend/diagnostic.cpp b/backend/src/backend/diagnostic.cpp
index ece16c7..5f63b78 100644
--- a/backend/src/backend/diagnostic.cpp
+++ b/backend/src/backend/diagnostic.cpp
@@ -1,3 +1,8 @@
+/*
+src/backend/diagnostic.cpp
+Contains code intended to perform any device diagnostics that
+can inform the health and reliability of the apparatus.
+*/
 #include "backend/diagnostic.h"
 #include <thread>
 
diff --git a/backend/src/backend/reception.cpp b/backend/src/backend/reception.cpp
index 1c3b197..ce34f6b 100644
--- a/backend/src/backend/reception.cpp
+++ b/backend/src/backend/reception.cpp
@@ -1,3 +1,8 @@
+/*
+src/backend/reception.cpp
+Convert script of steps provided by the frontend into sequence of 
+operations to be performed by the device.
+*/
 #include "backend/reception.h"
 
 namespace qm::backend {
diff --git a/backend/src/core/state_cache.cpp b/backend/src/core/state_cache.cpp
index 65dea23..682ce48 100644
--- a/backend/src/core/state_cache.cpp
+++ b/backend/src/core/state_cache.cpp
@@ -1,3 +1,9 @@
+/*
+src/core/state_cache.cpp
+Functions for accessing and storing signals that will be sent
+to the frontend to update the frontends schematic display of the 
+backend.
+*/
 #include "core/state_cache.h"
 #include <algorithm>
 
diff --git a/frontend/src/components/CircuitEditor.tsx b/frontend/src/components/CircuitEditor.tsx
index 9c77d91..65082e6 100644
--- a/frontend/src/components/CircuitEditor.tsx
+++ b/frontend/src/components/CircuitEditor.tsx
@@ -1,5 +1,5 @@
 // src/components/CircuitEditor.tsx
-import React, { useCallback } from "react";
+import React, { useCallback, useEffect } from "react";
 import { useDrag, useDrop } from "react-dnd";
 import { wrapDndRef } from "../utils/dndRefHelpers";
 import {
@@ -8,6 +8,7 @@ import {
   CircuitModel,
   CompositeGate,
   AtomicGate,
+  QubitBundle,
 } from "../state/useCircuitStore";
 
 import { GateEditDialog } from "./GateEditDialog"; // make sure this exists
@@ -22,15 +23,8 @@ const GATE_H = 40;
 // type guard
 const isCompositeGate = (g: GateModel): g is CompositeGate => (g as CompositeGate).type === "composite";
 
-interface DragItem {
-  id: string;
-  selectedIds: string[];
-  type: "GATE";
-}
-
-const DND_ITEM_TYPES = {
-  GATE: "GATE",
-} as const;
+interface DragItem { id: string; selectedIds: string[]; type: "GATE"; }
+const DND_ITEM_TYPES = { GATE: "GATE" } as const;
 
 /* ---------------- GateView ---------------- */
 
@@ -46,24 +40,19 @@ const GateView: React.FC<{
 
   const [{ isDragging }, dragRef] = useDrag<DragItem, void, { isDragging: boolean }>({
     type: DND_ITEM_TYPES.GATE,
-    item: {
-      id: gate.id,
-      selectedIds: selectedGateIds.includes(gate.id) ? selectedGateIds : [gate.id],
-      type: DND_ITEM_TYPES.GATE,
-    },
+    item: { id: gate.id, selectedIds: selectedGateIds.includes(gate.id) ? selectedGateIds : [gate.id], type: DND_ITEM_TYPES.GATE },
     collect: (monitor) => ({ isDragging: monitor.isDragging() }),
   });
 
   const refHandler = useCallback((node: HTMLDivElement | null) => wrapDndRef(node, dragRef), [dragRef]);
 
   const isComposite = (gate as any).type === "composite";
-  // composite visual height if we want it to overlap multiple rows
   const bundleHeight = isComposite ? (gate.qbits.length * ROW_HEIGHT - 8) : GATE_H;
 
   const handleContextMenu = (e: React.MouseEvent) => {
     e.preventDefault();
+    e.stopPropagation();
     if (!selected) onSelect(gate.id);
-    // use shared global function to open menu (keeps menu central)
     (window as any).__openContextAt?.(e, "gate", gate.id);
   };
 
@@ -86,21 +75,7 @@ const GateView: React.FC<{
         height: bundleHeight,
       }}
     >
-      {isComposite && (
-        <div
-          style={{
-            position: "absolute",
-            top: 0,
-            left: 0,
-            width: "100%",
-            height: "100%",
-            background: "rgba(147, 51, 234, 0.12)",
-            borderRadius: 6,
-            pointerEvents: "none",
-          }}
-        />
-      )}
-
+      {isComposite && <div style={{ position: "absolute", top: 0, left: 0, width: "100%", height: "100%", background: "rgba(147, 51, 234, 0.12)", borderRadius: 6, pointerEvents: "none" }} />}
       <div style={{ display: "flex", alignItems: "center", gap: 6, position: "relative", zIndex: 1 }}>
         <span style={{ fontWeight: 700 }}>{gate.symbol || gate.name}</span>
         {selected && (
@@ -108,28 +83,21 @@ const GateView: React.FC<{
             <button onClick={(ev) => { ev.stopPropagation(); onEdit(gate); }} title="Edit">âœŽ</button>
             <button onClick={(ev) => { ev.stopPropagation(); duplicateGate(gate.id); }} title="Duplicate">â§‰</button>
             <button onClick={(ev) => { ev.stopPropagation(); removeGate(gate.id); }} title="Delete">âœ•</button>
-
             {isComposite && (
-              <button
-                onClick={(ev) => {
-                  ev.stopPropagation();
-                  // expand composite into individual gates (map subcircuit qubit indices to parent)
-                  const subGates = (gate as CompositeGate).subCircuit.gates;
-                  subGates.forEach((g) => {
-                    const mappedQbits = g.qbits.map((q) => gate.qbits[q]);
-                    useCircuitStore.getState().addGate({
-                      ...g,
-                      id: crypto.randomUUID(),
-                      column: (gate.column ?? 0) + (g.column ?? 0),
-                      qbits: mappedQbits,
-                    } as GateModel);
-                  });
-                  useCircuitStore.getState().removeGate(gate.id);
-                }}
-                title="Expand"
-              >
-                ðŸ”½
-              </button>
+              <button onClick={(ev) => {
+                ev.stopPropagation();
+                const subGates = (gate as CompositeGate).subCircuit.gates;
+                subGates.forEach((g) => {
+                  const mappedQbits = g.qbits.map((q) => gate.qbits[q]);
+                  useCircuitStore.getState().addGate({
+                    ...g,
+                    id: crypto.randomUUID(),
+                    column: (gate.column ?? 0) + (g.column ?? 0),
+                    qbits: mappedQbits,
+                  } as GateModel);
+                });
+                useCircuitStore.getState().removeGate(gate.id);
+              }} title="Expand">ðŸ”½</button>
             )}
           </div>
         )}
@@ -155,7 +123,6 @@ const QubitLine: React.FC<{
   const [, dropRef] = useDrop<DragItem, void, any>({
     accept: [DND_ITEM_TYPES.GATE],
     drop: (item) => {
-      // Move all selected gates to this qubit/column (simple: map to this qbit)
       const qbitsForEach: Record<string, number[]> = {};
       item.selectedIds.forEach((id) => (qbitsForEach[id] = [index]));
       moveGatesTo(item.selectedIds, 0, qbitsForEach);
@@ -167,14 +134,8 @@ const QubitLine: React.FC<{
   return (
     <div
       ref={refHandler}
-      onClick={(e) => {
-        e.stopPropagation();
-        toggleSelectQubit(index, e.ctrlKey || e.metaKey);
-      }}
-      onContextMenu={(e) => {
-        e.preventDefault(); e.stopPropagation();
-        openContextAt(e, "qubit", index);
-      }}
+      onClick={(e) => { e.stopPropagation(); toggleSelectQubit(index, e.ctrlKey || e.metaKey); }}
+      onContextMenu={(e) => { e.preventDefault(); e.stopPropagation(); openContextAt(e, "qubit", index); }}
       style={{
         display: "flex",
         alignItems: "center",
@@ -188,17 +149,9 @@ const QubitLine: React.FC<{
     >
       <div style={{ width: 48, color: "#6b7280", fontFamily: "monospace" }}>{`q[${index}]`}</div>
       <div style={{ flex: 1 }}>
-        {gates
-          .filter((g) => g.qbits.includes(index))
-          .map((g) => (
-            <GateView
-              key={g.id}
-              gate={g}
-              selected={selectedGateIds.includes(g.id)}
-              onSelect={onSelectGate}
-              onEdit={onEditGate}
-            />
-          ))}
+        {gates.filter((g) => g.qbits.includes(index)).map((g) => (
+          <GateView key={g.id} gate={g} selected={selectedGateIds.includes(g.id)} onSelect={onSelectGate} onEdit={onEditGate} />
+        ))}
       </div>
     </div>
   );
@@ -211,33 +164,34 @@ const QubitBundleLine: React.FC<{
   isSelected: boolean;
   openContextAt: (e: React.MouseEvent, kind: "gate" | "qubit", target?: string | number) => void;
 }> = ({ bundle, isSelected, openContextAt }) => {
-  const palette = ["#3b82f6", "#22c55e", "#eab308", "#f97316", "#ec4899", "#8b5cf6"];
+  const palette = ["#3b82f6", "#22c55e", "#f59e0b", "#f97316", "#ec4899", "#8b5cf6"];
 
   return (
-    <div
-      onContextMenu={(e) => openContextAt(e, "qubit", bundle.id)}
+    <div onContextMenu={(e) => { e.preventDefault(); e.stopPropagation(); openContextAt(e, "qubit", bundle.id); }}
       style={{
-        display: "flex",
-        alignItems: "center",
-        padding: "4px 10px",
-        margin: "4px 0",
-        borderLeft: isSelected ? "3px solid #3b82f6" : "3px solid transparent",
-        background: "rgba(0,0,0,0.02)",
-        borderRadius: 6,
-        fontSize: "0.92rem",
-        cursor: "pointer",
-        minHeight: 28,
-      }}
-    >
-      <div style={{ flex: 1 }}>
-        <span style={{ color: bundle.color ?? "#0ea5e9", fontWeight: 700 }}>|{bundle.name}&gt;</span>{" "}
-        <span style={{ opacity: 0.75, marginLeft: 6 }}>{bundle.qbits.map((q) => `q${q}`).join(", ")}</span>
+        display: "flex", alignItems: "center", padding: "4px 10px", margin: "4px 0",
+        borderLeft: isSelected ? "3px solid #3b82f6" : "3px solid transparent", background: "rgba(0,0,0,0.02)",
+        borderRadius: 6, fontSize: "0.92rem", cursor: "pointer", minHeight: 28,
+      }}>
+      <div style={{ display: "flex", alignItems: "center", gap: 8, flex: 1 }}>
+        <svg width={140} height={28} viewBox="0 0 140 28" style={{ flex: "none" }}>
+          <path d="M 6 14 L 110 14" stroke="#e5e7eb" strokeWidth={1} fill="none" />
+          <circle cx={12} cy={14} r={6} fill={bundle.color ?? "#0ea5e9"} />
+          {bundle.qbits.map((_, i) => {
+            const cx = 40 + i * 18;
+            const cy = 14;
+            const d = `M ${cx - 12} ${cy} q 10 -8 20 0`;
+            const color = palette[i % palette.length];
+            return <path key={i} d={d} stroke={color} strokeWidth={2} fill="none" strokeLinecap="round" />;
+          })}
+        </svg>
+
+        <div style={{ fontWeight: 700, color: bundle.color ?? "#0ea5e9" }}>|{bundle.name}&gt;</div>
+        <div style={{ opacity: 0.75, marginLeft: 6 }}>{bundle.qbits.map((q) => `q${q}`).join(", ")}</div>
       </div>
 
       <div style={{ display: "flex", gap: 6 }}>
-        {bundle.qbits.map((_, i) => (
-          <div key={i} style={{ width: 14, height: 8, borderRadius: 3, background: palette[i % palette.length] }} />
-        ))}
+        {bundle.qbits.map((_, i) => <div key={i} style={{ width: 14, height: 8, borderRadius: 3, background: palette[i % palette.length] }} />)}
       </div>
     </div>
   );
@@ -256,6 +210,8 @@ export const CircuitEditor: React.FC<{ circuit?: CircuitModel }> = ({ circuit })
     addGate,
     saveCircuit,
     loadCircuit,
+    undo,
+    redo,
   } = useCircuitStore();
 
   const c = circuit ?? storeCircuit;
@@ -268,16 +224,12 @@ export const CircuitEditor: React.FC<{ circuit?: CircuitModel }> = ({ circuit })
   const groupSelectedGates = useCircuitStore((s) => s.groupSelectedGates);
 
   // context menu (shared for gates & qubit rows)
-  const [ctxMenu, setCtxMenu] = React.useState<{
-    x: number;
-    y: number;
-    kind: "gate" | "qubit" | null;
-    targetId?: string | number;
-  } | null>(null);
+  const [ctxMenu, setCtxMenu] = React.useState<{ x: number; y: number; kind: "gate" | "qubit" | null; targetId?: string | number } | null>(null);
 
   // Expose globally, so GateView and QubitLine can invoke it
   const openContextAt = (e: React.MouseEvent, kind: "gate" | "qubit", target?: string | number) => {
     e.preventDefault();
+    e.stopPropagation();
     setCtxMenu({ x: e.clientX, y: e.clientY, kind, targetId: target });
   };
   (window as any).__openContextAt = openContextAt;
@@ -310,24 +262,11 @@ export const CircuitEditor: React.FC<{ circuit?: CircuitModel }> = ({ circuit })
   /* Add identity gate (atomic) */
   const handleAddGate = () => {
     if (c.numQubits === 0) return;
-    const firstSelectedQbit =
-      selectedGateIds.length > 0
-        ? useCircuitStore.getState().circuit.gates.find((g) => g.id === selectedGateIds[0])?.qbits[0] ?? 0
-        : 0;
-
+    const firstSelectedQbit = selectedGateIds.length > 0 ? useCircuitStore.getState().circuit.gates.find((g) => g.id === selectedGateIds[0])?.qbits[0] ?? 0 : 0;
     const newGate: AtomicGate = {
-      id: crypto.randomUUID(),
-      type: "atomic",
-      name: "Identity",
-      symbol: "I",
-      qbits: [firstSelectedQbit],
-      column: 0,
-      matrix: [
-        [{ re: 1, im: 0 }, { re: 0, im: 0 }],
-        [{ re: 0, im: 0 }, { re: 1, im: 0 }],
-      ],
+      id: crypto.randomUUID(), type: "atomic", name: "Identity", symbol: "I", qbits: [firstSelectedQbit], column: 0,
+      matrix: [[{ re: 1, im: 0 }, { re: 0, im: 0 }], [{ re: 0, im: 0 }, { re: 1, im: 0 }]],
     };
-
     addGate(newGate as GateModel);
   };
 
@@ -339,41 +278,67 @@ export const CircuitEditor: React.FC<{ circuit?: CircuitModel }> = ({ circuit })
 
   const handleEditGate = (g: GateModel) => setEditingGate(g);
 
+  // overlay drawing for bundles: draws curved connectors from bundle head to gates that use its qubits
+  const renderBundleOverlaySVG = () => {
+    if (!bundles?.length) return null;
+    const width = Math.max(800, typeof window !== "undefined" ? window.innerWidth - 40 : 900);
+    const height = Math.max(200, c.numQubits * (ROW_HEIGHT / 1.5) + 80);
+    const columnX = (col: number) => LEFT_MARGIN + col * COL_WIDTH;
+    const rowY = (q: number) => 40 + q * (ROW_HEIGHT / 2);
+
+    const paths: { d: string; color: string }[] = [];
+
+    bundles.forEach((b) => {
+      c.gates.forEach((g) => {
+        if (!g.qbits.some((q) => b.qbits.includes(q))) return;
+        const fromX = 8;
+        const fromY = rowY(b.qbits[0]);
+        const toX = columnX(g.column ?? 0) + GATE_W / 2;
+        const toY = rowY(g.qbits[0]);
+        const midX = (fromX + toX) / 2;
+        const d = `M ${fromX} ${fromY} C ${midX} ${fromY} ${midX} ${toY} ${toX} ${toY}`;
+        paths.push({ d, color: b.color ?? "#0ea5e9" });
+      });
+    });
+
+    return (
+      <svg style={{ position: "absolute", left: 0, top: 0, pointerEvents: "none" }} width="100%" height={height}>
+        {paths.map((p, i) => <path key={i} d={p.d} stroke={p.color} strokeWidth={2} fill="none" strokeLinecap="round" />)}
+      </svg>
+    );
+  };
+
   /* Render helpers - render either a bundle header or a normal qubit row */
   const renderQubitOrBundle = (i: number) => {
-    // find bundle whose head is i
     const headBundle = bundles.find((b) => b.qbits[0] === i);
     if (headBundle) {
-      return (
-        <QubitBundleLine
-          key={`bundle-${headBundle.id}`}
-          bundle={headBundle}
-          isSelected={headBundle.qbits.some((q) => selectedQubits.includes(q))}
-          openContextAt={openContextAt}
-        />
-      );
+      return <QubitBundleLine key={`bundle-${headBundle.id}`} bundle={headBundle} isSelected={headBundle.qbits.some((q) => selectedQubits.includes(q))} openContextAt={openContextAt} />;
     }
-
-    // skip lines that belong to a bundle but are not the head
     if (bundles.some((b) => b.qbits.includes(i) && b.qbits[0] !== i)) return null;
-
-    return (
-      <QubitLine
-        key={i}
-        index={i}
-        gates={c.gates}
-        selectedGateIds={selectedGateIds}
-        onSelectGate={handleSelectGate}
-        onEditGate={handleEditGate}
-        isSelected={selectedQubits.includes(i)}
-        toggleSelectQubit={toggleSelectQubit}
-        openContextAt={openContextAt}
-      />
-    );
+    return <QubitLine key={i} index={i} gates={c.gates} selectedGateIds={selectedGateIds} onSelectGate={handleSelectGate} onEditGate={handleEditGate} isSelected={selectedQubits.includes(i)} toggleSelectQubit={toggleSelectQubit} openContextAt={openContextAt} />;
   };
 
+  // keyboard handlers for undo/redo
+  useEffect(() => {
+    const handler = (e: KeyboardEvent) => {
+      const z = e.key.toLowerCase() === "z";
+      const y = e.key.toLowerCase() === "y";
+      const isCtrl = e.ctrlKey || e.metaKey;
+      if (!isCtrl) return;
+      if (z && !e.shiftKey) {
+        e.preventDefault();
+        undo();
+      } else if ((z && e.shiftKey) || y) {
+        e.preventDefault();
+        redo();
+      }
+    };
+    window.addEventListener("keydown", handler);
+    return () => window.removeEventListener("keydown", handler);
+  }, [undo, redo]);
+
   return (
-    <div className="p-4 bg-gray-50 h-full">
+    <div className="p-4 bg-gray-50 h-full" style={{ position: "relative" }}>
       <div className="flex gap-2 mb-4">
         <button onClick={handleAddGate} className="bg-blue-500 text-white px-2 py-1 rounded">Add Identity</button>
         <button onClick={addQubit} className="bg-green-500 text-white px-2 py-1 rounded">Add Qubit</button>
@@ -382,84 +347,35 @@ export const CircuitEditor: React.FC<{ circuit?: CircuitModel }> = ({ circuit })
         <button onClick={loadCircuit} className="bg-purple-500 text-white px-2 py-1 rounded">Load</button>
       </div>
 
-      {/* Qubits / bundles (compact) */}
-      <div>
-        {Array.from({ length: c.numQubits }).map((_, i) => renderQubitOrBundle(i))}
-      </div>
+      <div>{Array.from({ length: c.numQubits }).map((_, i) => renderQubitOrBundle(i))}</div>
+
+      {renderBundleOverlaySVG()}
 
-      {/* shared context menu */}
       {ctxMenu && (
-        <div
-          style={{
-            position: "fixed",
-            left: ctxMenu.x,
-            top: ctxMenu.y,
-            background: "white",
-            border: "1px solid #ddd",
-            boxShadow: "0 6px 18px rgba(0,0,0,0.08)",
-            zIndex: 2000,
-            padding: 8,
-            borderRadius: 6,
-          }}
-          onMouseLeave={() => setTimeout(closeContext, 200)}
-        >
+        <div style={{ position: "fixed", left: ctxMenu.x, top: ctxMenu.y, background: "white", border: "1px solid #ddd", boxShadow: "0 6px 18px rgba(0,0,0,0.08)", zIndex: 2000, padding: 8, borderRadius: 6 }} onMouseLeave={() => setTimeout(closeContext, 200)}>
           {/* Group gates */}
-          {ctxMenu.kind === "gate" && selectedGateIds.length > 1 && (
-            <div style={{ padding: 6, cursor: "pointer" }} onClick={handleGroupSelectedGates}>
-              Group selected gates
-            </div>
-          )}
-
-          {/* Expand/ungroup composite gate (if the target is a composite gate) */}
+          {ctxMenu.kind === "gate" && selectedGateIds.length > 1 && <div style={{ padding: 6, cursor: "pointer" }} onClick={handleGroupSelectedGates}>Group selected gates</div>}
           {ctxMenu.kind === "gate" && typeof ctxMenu.targetId === "string" && (() => {
             const g = c.gates.find((x) => x.id === ctxMenu.targetId);
             if (g && g.type === "composite") {
-              return (
-                <div
-                  style={{ padding: 6, cursor: "pointer" }}
-                  onClick={() => {
-                    useCircuitStore.getState().ungroupCompositeGate(g.id);
-                    closeContext();
-                  }}
-                >
-                  Expand / Ungroup
-                </div>
-              );
+              return <div style={{ padding: 6, cursor: "pointer" }} onClick={() => { useCircuitStore.getState().ungroupCompositeGate(g.id); closeContext(); }}>Expand / Ungroup</div>;
             }
             return null;
           })()}
-
-          {/* Create bundle from qubit selection */}
-          {ctxMenu.kind === "qubit" && selectedQubits.length > 1 && (
-            <div style={{ padding: 6, cursor: "pointer" }} onClick={handleCreateBundleFromSelection}>
-              Create bundle from selected qubits
-            </div>
-          )}
-
-          {/* Unbundle (if right-clicked on a bundle) */}
+          {ctxMenu.kind === "qubit" && selectedQubits.length > 1 && <div style={{ padding: 6, cursor: "pointer" }} onClick={handleCreateBundleFromSelection}>Create bundle from selected qubits</div>}
           {ctxMenu.kind === "qubit" && typeof ctxMenu.targetId !== "undefined" && (() => {
             const maybeBundle = bundles.find((b) => b.id === String(ctxMenu.targetId) || b.qbits[0] === Number(ctxMenu.targetId));
-            if (maybeBundle) {
-              return (
-                <div style={{ padding: 6, cursor: "pointer" }} onClick={() => handleUnbundle(maybeBundle.id)}>
-                  Unbundle qubits
-                </div>
-              );
-            }
+            if (maybeBundle) return <div style={{ padding: 6, cursor: "pointer" }} onClick={() => handleUnbundle(maybeBundle.id)}>Unbundle qubits</div>;
             return null;
           })()}
         </div>
       )}
 
-      {/* Gate edit modal */}
       {editingGate && (
         <GateEditDialog
           gate={editingGate}
           totalQubits={c.numQubits}
-          onSave={(g) => {
-            useCircuitStore.getState().updateGate(g.id, g);
-            setEditingGate(null);
-          }}
+          onSave={(g) => { useCircuitStore.getState().updateGate(g.id, g); setEditingGate(null); }}
           onCancel={() => setEditingGate(null)}
         />
       )}
diff --git a/frontend/src/components/GateEditDialog.tsx b/frontend/src/components/GateEditDialog.tsx
index 5bf10a3..324784c 100644
--- a/frontend/src/components/GateEditDialog.tsx
+++ b/frontend/src/components/GateEditDialog.tsx
@@ -1,49 +1,32 @@
 // src/components/GateEditDialog.tsx
-import React, { useRef, useState, useEffect } from "react";
-import {
-  Dialog,
-  DialogContent,
-  DialogHeader,
-  DialogTitle,
-} from "./ui/dialog";
+import React, { useEffect, useState } from "react";
+import { Dialog, DialogContent, DialogHeader, DialogTitle } from "./ui/dialog";
 import { Input } from "./ui/input";
 import { Button } from "./ui/button";
-import {
-  Select,
-  SelectTrigger,
-  SelectContent,
-  SelectItem,
-  SelectValue,
-} from "./ui/select";
+import { Select, SelectTrigger, SelectContent, SelectItem, SelectValue } from "./ui/select";
 import { Alert, AlertDescription } from "./ui/alert";
 import * as math from "mathjs";
-import {
-  useCircuitStore,
-  GateModel,
-  ComplexNumber,
-  CompositeGate,
-} from "../state/useCircuitStore";
+import { parse as papaParse } from "papaparse";
+import { useCircuitStore, GateModel, ComplexNumber, CompositeGate } from "../state/useCircuitStore";
 
 /********* Helpers *********/
-
 const generateIdentity = (dim: number): ComplexNumber[][] =>
   Array.from({ length: dim }, (_, r) =>
-    Array.from({ length: dim }, (_, c) => ({
-      re: r === c ? 1 : 0,
-      im: 0,
-    }))
+    Array.from({ length: dim }, (_, c) => ({ re: r === c ? 1 : 0, im: 0 }))
   );
 
 const parseComplexInput = (input: string): ComplexNumber | null => {
   try {
-    const v = math.complex(input.replace(/\s+/g, ""));
+    const cleaned = input.replace(/\s+/g, "");
+    const v = math.complex(cleaned);
     return { re: v.re, im: v.im };
   } catch {
     return null;
   }
 };
 
-const formatComplex = (c: ComplexNumber) => {
+const formatComplex = (c: ComplexNumber | undefined) => {
+  if (!c) return "0";
   if (c.im === 0) return `${c.re}`;
   if (c.re === 0) return `${c.im}i`;
   const sign = c.im >= 0 ? "+" : "-";
@@ -51,179 +34,93 @@ const formatComplex = (c: ComplexNumber) => {
 };
 
 /********* Basic Gates *********/
-
-const basicGates: Record<
-  string,
-  { label: string; qubits: number; matrix: ComplexNumber[][] }
-> = {
+const basicGates: Record<string, { label: string; qubits: number; matrix: ComplexNumber[][] }> = {
   I: { label: "Identity", qubits: 1, matrix: generateIdentity(2) },
-  H: {
-    label: "Hadamard",
-    qubits: 1,
-    matrix: [
-      [
-        { re: 1 / Math.sqrt(2), im: 0 },
-        { re: 1 / Math.sqrt(2), im: 0 },
-      ],
-      [
-        { re: 1 / Math.sqrt(2), im: 0 },
-        { re: -1 / Math.sqrt(2), im: 0 },
-      ],
-    ],
-  },
-  X: {
-    label: "Pauli-X",
-    qubits: 1,
-    matrix: [
-      [
-        { re: 0, im: 0 },
-        { re: 1, im: 0 },
-      ],
-      [
-        { re: 1, im: 0 },
-        { re: 0, im: 0 },
-      ],
-    ],
-  },
-  Y: {
-    label: "Pauli-Y",
-    qubits: 1,
-    matrix: [
-      [
-        { re: 0, im: 0 },
-        { re: 0, im: -1 },
-      ],
-      [
-        { re: 0, im: 1 },
-        { re: 0, im: 0 },
-      ],
-    ],
-  },
-  Z: {
-    label: "Pauli-Z",
-    qubits: 1,
-    matrix: [
-      [
-        { re: 1, im: 0 },
-        { re: 0, im: 0 },
-      ],
-      [
-        { re: 0, im: 0 },
-        { re: -1, im: 0 },
-      ],
-    ],
-  },
+  H: { label: "Hadamard", qubits: 1, matrix: [[{ re: 1 / Math.sqrt(2), im: 0 }, { re: 1 / Math.sqrt(2), im: 0 }], [{ re: 1 / Math.sqrt(2), im: 0 }, { re: -1 / Math.sqrt(2), im: 0 }]] },
+  X: { label: "Pauli-X", qubits: 1, matrix: [[{ re: 0, im: 0 }, { re: 1, im: 0 }], [{ re: 1, im: 0 }, { re: 0, im: 0 }]] },
+  Y: { label: "Pauli-Y", qubits: 1, matrix: [[{ re: 0, im: 0 }, { re: 0, im: -1 }], [{ re: 0, im: 1 }, { re: 0, im: 0 }]] },
+  Z: { label: "Pauli-Z", qubits: 1, matrix: [[{ re: 1, im: 0 }, { re: 0, im: 0 }], [{ re: 0, im: 0 }, { re: -1, im: 0 }]] },
   CNOT: {
-    label: "CNOT",
-    qubits: 2,
-    matrix: [
-      [
-        { re: 1, im: 0 },
-        { re: 0, im: 0 },
-        { re: 0, im: 0 },
-        { re: 0, im: 0 },
-      ],
-      [
-        { re: 0, im: 0 },
-        { re: 1, im: 0 },
-        { re: 0, im: 0 },
-        { re: 0, im: 0 },
-      ],
-      [
-        { re: 0, im: 0 },
-        { re: 0, im: 0 },
-        { re: 0, im: 0 },
-        { re: 1, im: 0 },
-      ],
-      [
-        { re: 0, im: 0 },
-        { re: 0, im: 0 },
-        { re: 1, im: 0 },
-        { re: 0, im: 0 },
-      ],
-    ],
+    label: "CNOT", qubits: 2, matrix: [
+      [{ re: 1, im: 0 }, { re: 0, im: 0 }, { re: 0, im: 0 }, { re: 0, im: 0 }],
+      [{ re: 0, im: 0 }, { re: 1, im: 0 }, { re: 0, im: 0 }, { re: 0, im: 0 }],
+      [{ re: 0, im: 0 }, { re: 0, im: 0 }, { re: 0, im: 0 }, { re: 1, im: 0 }],
+      [{ re: 0, im: 0 }, { re: 0, im: 0 }, { re: 1, im: 0 }, { re: 0, im: 0 }],
+    ]
   },
 };
 
 /********* Component *********/
-
 export const GateEditDialog: React.FC<{
   gate: GateModel;
-  totalQubits: number; // pass from CircuitEditor
+  totalQubits: number;
   onSave: (gate: GateModel) => void;
   onCancel: () => void;
 }> = ({ gate, totalQubits, onSave, onCancel }) => {
-  const editingGate = useCircuitStore((s) => s.editingGate);
   const setEditingGate = useCircuitStore((s) => s.setEditingGate);
-  const updateGate = useCircuitStore((s) => s.updateGate);
-
-  const skipFirstOnOpenChange = useRef(false);
-  const [open, setOpen] = useState<boolean>(!!editingGate);
 
-  /** Gate editor state */
-  const [name, setName] = useState(gate.name);
-  const [symbol, setSymbol] = useState(gate.symbol);
-  const [numQubits, setNumQubits] = useState(gate.qbits.length);
-  const [matrix, setMatrix] = useState<ComplexNumber[][]>(gate.matrix);
-  const [color, setColor] = useState<string>(gate.color || "#2563eb");
-  const [selectedGate, setSelectedGate] = useState<string>("custom");
+  const [name, setName] = useState(gate.name || "");
+  const [symbol, setSymbol] = useState(gate.symbol || "");
+  const [color, setColor] = useState((gate as any).color || "#2563eb");
+  const [selectedQbits, setSelectedQbits] = useState<number[]>([...(gate.qbits || [])]);
+  const [numQubits, setNumQubits] = useState(Math.max(1, gate.qbits.length || 1));
+  const [matrix, setMatrix] = useState<ComplexNumber[][]>(gate.matrix ?? generateIdentity(2 ** Math.max(1, gate.qbits.length || 1)));
   const [error, setError] = useState<string | null>(null);
-  const [invalidCells, setInvalidCells] = useState<Set<string>>(new Set());
-  const [rawInputs, setRawInputs] = useState<Record<string, string>>({});
-
-  /** Only for CompositeGate: mapping subcircuit qubits to parent circuit */
-  const [qubitMapping, setQubitMapping] = useState<number[]>(
-    gate.type === "composite"
-      ? (gate.qubitMapping?.slice() ?? gate.qbits.slice())
-      : []
-  );
+  const [selectedGate, setSelectedGate] = useState<string>("custom");
 
-  /** Sync state when editingGate changes */
   useEffect(() => {
-    if (!editingGate) return;
-
-    setName(editingGate.name);
-    setSymbol(editingGate.symbol);
-    setNumQubits(editingGate.qbits.length);
-    setMatrix(
-      editingGate.matrix || generateIdentity(2 ** editingGate.qbits.length)
-    );
-    setRawInputs({});
-
-    setQubitMapping(
-      editingGate.type === "composite"
-        ? (editingGate as CompositeGate).qubitMapping?.slice() ??
-          editingGate.qbits.slice()
-        : []
-    );
-  }, [editingGate?.id]);
+    setName(gate.name || "");
+    setSymbol(gate.symbol || "");
+    setColor((gate as any).color || "#2563eb");
+    setSelectedQbits([...(gate.qbits || [])].slice(0, totalQubits));
+    const dim = gate.matrix ? gate.matrix.length : 2 ** Math.max(1, gate.qbits.length || 1);
+    setMatrix(gate.matrix ? gate.matrix : generateIdentity(dim));
+    setNumQubits(Math.max(1, (gate.qbits && gate.qbits.length) || 1));
+    setError(null);
+  }, [gate, totalQubits]);
+
+  const handleNumQubitsChange = (newVal: number) => {
+    const limited = Math.max(1, Math.min(totalQubits, newVal));
+    setNumQubits(limited);
+    const newDim = 2 ** limited;
+    setMatrix((old) => {
+      const out = generateIdentity(newDim);
+      for (let r = 0; r < Math.min(newDim, old.length); r++) {
+        for (let c = 0; c < Math.min(newDim, (old[r] || []).length); c++) out[r][c] = old[r][c];
+      }
+      return out;
+    });
+    setSelectedQbits((prev) => prev.filter((q) => q < totalQubits).slice(0, limited));
+    setError(null);
+  };
 
-  /** Matrix validation */
-  const validateMatrix = (m: ComplexNumber[][]) => {
-    const bad = new Set<string>();
-    m.forEach((row, r) =>
-      row.forEach((cell, c) => {
-        if (Number.isNaN(cell.re) || Number.isNaN(cell.im)) bad.add(`${r}-${c}`);
-      })
-    );
-    setInvalidCells(bad);
-    setError(bad.size > 0 ? "Some entries contain invalid complex expressions." : null);
+  const toggleQbitSelection = (i: number) => {
+    setSelectedQbits((s) => {
+      const cur = new Set(s);
+      if (cur.has(i)) cur.delete(i); else cur.add(i);
+      return Array.from(cur).sort((a, b) => a - b);
+    });
   };
 
-  /** Handle blur (defer validation until focus leaves) */
-  const handleBlurMatrix = (r: number, c: number) => {
-    const expr = rawInputs[`${r}-${c}`];
-    const parsed = parseComplexInput(expr);
+  const handleCellChange = (r: number, c: number, raw: string) => {
+    const parsed = parseComplexInput(raw);
     setMatrix((m) => {
       const copy = m.map((row) => row.map((cell) => ({ ...cell })));
-      copy[r][c] = parsed ?? { re: NaN, im: NaN };
-      validateMatrix(copy);
+      if (!parsed) { copy[r][c] = { re: NaN, im: NaN }; setError(`Invalid complex expression at [${r},${c}]`); }
+      else { copy[r][c] = parsed; const anyBad = copy.some((row) => row.some((cell) => Number.isNaN(cell.re) || Number.isNaN(cell.im))); setError(anyBad ? "Some entries invalid" : null); }
       return copy;
     });
   };
 
-  const handleChangeMatrix = (r: number, c: number, val: string) => {
-    setRawInputs((prev) => ({ ...prev, [`${r}-${c}`]: val }));
+  const handleImportCSV = (e: React.ChangeEvent<HTMLInputElement>) => {
+    const file = e.target.files?.[0];
+    if (!file) return;
+    file.text().then((t) => {
+      const parsed = papaParse(t, { dynamicTyping: true }).data as any[][];
+      const newMatrix = parsed.map((row) => row.map((val) => ({ re: Number(val) || 0, im: 0 })));
+      setMatrix(newMatrix);
+      setError(null);
+    });
   };
 
   const handlePreset = (key: string) => {
@@ -239,193 +136,138 @@ export const GateEditDialog: React.FC<{
   };
 
   const handleSave = () => {
-    if (invalidCells.size > 0) {
-      setError("Cannot save: matrix contains invalid cells.");
+    if (matrix.some((r) => r.some((c) => Number.isNaN(c.re) || Number.isNaN(c.im)))) {
+      setError("Cannot save: matrix contains invalid entries");
       return;
     }
-    if (!editingGate) return;
 
-    const updatedGate: GateModel = {
-      ...editingGate,
+    const out: GateModel = {
+      ...gate,
+      id: gate.id,
       name,
       symbol,
       color,
-      qbits:
-        editingGate.type === "composite"
-          ? qubitMapping.slice()
-          : editingGate.qbits.slice(),
+      column: (gate as any).column ?? 0,
+      qbits: selectedQbits.length ? selectedQbits.slice() : gate.qbits.slice(),
       matrix,
-      ...(editingGate.type === "composite" ? { qubitMapping: qubitMapping.slice() } : {}),
-    };
+      ...( (gate as CompositeGate).type === "composite"
+          ? { type: "composite", subCircuit: (gate as CompositeGate).subCircuit, qubitMapping: (gate as CompositeGate).qubitMapping?.slice() ?? (selectedQbits.slice()) }
+          : { type: "atomic" }
+      )
+    } as GateModel;
 
-    updateGate(editingGate.id, updatedGate);
+    onSave(out);
     setEditingGate(null);
-    onSave(updatedGate);
   };
 
-  if (!editingGate) return null;
+  // mini preview:
+  const PreviewSVG: React.FC = () => {
+    const rows = Math.max(1, numQubits);
+    const w = 320; const rowSpacing = 28; const h = Math.max(40, rows * rowSpacing + 8);
+    const leftPad = 12; const boxX = 140; const boxW = 44; const boxH = Math.max(18, Math.min(28, rows * 0.6));
+    const gateCenterY = (() => {
+      if (selectedQbits.length === 0) return h / 2;
+      const ys = selectedQbits.map((q) => leftPad + q * rowSpacing + 6);
+      return ys.reduce((a, b) => a + b, 0) / ys.length;
+    })();
+
+    return (
+      <svg width="100%" height={h} viewBox={`0 0 ${w} ${h}`} preserveAspectRatio="xMinYMid meet">
+        {Array.from({ length: rows }).map((_, i) => {
+          const y = leftPad + i * rowSpacing;
+          return <line key={i} x1={8} x2={w - 8} y1={y} y2={y} stroke="#e5e7eb" strokeWidth={1} />;
+        })}
+        {selectedQbits.map((q, idx) => {
+          if (q >= rows) return null;
+          const y = leftPad + q * rowSpacing;
+          const midX = (8 + boxX) / 2;
+          const d = `M ${8} ${y} Q ${midX} ${y} ${boxX} ${gateCenterY}`;
+          return <path key={idx} d={d} stroke="#0ea5e9" strokeWidth={2} fill="none" strokeLinecap="round" />;
+        })}
+        <rect x={boxX} y={gateCenterY - boxH / 2} width={boxW} height={boxH} rx={4} fill={color} />
+        <text x={boxX + boxW / 2} y={gateCenterY + 4} fontSize={12} textAnchor="middle" fill="#fff">{symbol || name || "G"}</text>
+      </svg>
+    );
+  };
 
   return (
-    <Dialog
-      open={!!editingGate && open}
-      onOpenChange={(isOpen) => {
-        if (skipFirstOnOpenChange.current) {
-          skipFirstOnOpenChange.current = false;
-          setOpen(isOpen);
-          return;
-        }
-        setOpen(isOpen);
-        if (!isOpen) setEditingGate(null);
-      }}
-    >
+    <Dialog open={true} onOpenChange={() => { setEditingGate(null); onCancel(); }}>
       <DialogContent className="max-w-2xl">
-        <DialogHeader>
-          <DialogTitle>Edit Gate</DialogTitle>
-        </DialogHeader>
-
-        {error && (
-          <Alert variant="destructive" className="mb-2">
-            <AlertDescription>{error}</AlertDescription>
-          </Alert>
-        )}
-
-        {/* Basic Fields */}
-        <div className="flex gap-2 mb-2">
-          <Input placeholder="Name" value={name} onChange={(e) => setName(e.target.value)} />
-          <Input placeholder="Symbol" value={symbol} onChange={(e) => setSymbol(e.target.value)} />
-        </div>
+        <DialogHeader><DialogTitle>Edit Gate</DialogTitle></DialogHeader>
+        <div className="flex flex-col gap-4">
+          {error && <Alert variant="destructive"><AlertDescription>{error}</AlertDescription></Alert>}
+          <div className="flex gap-2">
+            <Input placeholder="Name" value={name} onChange={(e) => setName(e.target.value)} />
+            <Input placeholder="Symbol" value={symbol} onChange={(e) => setSymbol(e.target.value)} />
+            <input type="color" value={color} onChange={(e) => setColor(e.target.value)} title="Gate color" />
+          </div>
 
-        {/* color picker */}
-        <label className="flex flex-col gap-1">
-          <span className="text-sm font-medium">Color</span>
-          <input type="color" value={color} onChange={(e) => setColor(e.target.value)} />
-        </label>
+          <div className="flex items-center gap-2 mb-2">
+            <span className="text-sm font-medium">Load Preset:</span>
+            <Select onValueChange={handlePreset} value={selectedGate}>
+              <SelectTrigger className="w-48"><SelectValue placeholder="Choose gate..." /></SelectTrigger>
+              <SelectContent>
+                <SelectItem value="custom">Custom</SelectItem>
+                {Object.entries(basicGates).map(([key, val]) => <SelectItem key={key} value={key}>{val.label}</SelectItem>)}
+              </SelectContent>
+            </Select>
+          </div>
 
-        {/* Preset Selector */}
-        <div className="flex items-center gap-2 mb-2">
-          <span className="text-sm font-medium">Load Preset:</span>
-          <Select onValueChange={handlePreset} value={selectedGate}>
-            <SelectTrigger className="w-48">
-              <SelectValue placeholder="Choose gate..." />
-            </SelectTrigger>
-            <SelectContent>
-              <SelectItem value="custom">Custom</SelectItem>
-              {Object.entries(basicGates).map(([key, val]) => (
-                <SelectItem key={key} value={key}>
-                  {val.label}
-                </SelectItem>
+          <div>
+            <span className="text-sm">Select qubits (these indices map gate â†’ circuit qubits)</span>
+            <div className="flex gap-2 mt-2 flex-wrap">
+              {Array.from({ length: totalQubits }).map((_, i) => (
+                <label key={i} style={{ display: "inline-flex", alignItems: "center", gap: 6 }}>
+                  <input type="checkbox" checked={selectedQbits.includes(i)} onChange={() => toggleQbitSelection(i)} />
+                  <span>q{i}</span>
+                </label>
               ))}
-            </SelectContent>
-          </Select>
-        </div>
+            </div>
+          </div>
 
-        {/* Qubit Count */}
-        <label className="flex flex-col gap-1 mb-2">
-          <span className="text-sm font-medium">Number of Qubits</span>
-          <Input
-            type="number"
-            value={numQubits}
-            min={1}
-            max={totalQubits}
-            disabled={editingGate.type === "composite"} // composite gates cannot change qubit count
-            onChange={(e) => setNumQubits(parseInt(e.target.value))}
-          />
-        </label>
+          <div className="flex gap-2">
+            <label>
+              <span className="text-sm">Gate width (qubits)</span>
+              <Input type="number" value={numQubits} min={1} max={Math.min(4, totalQubits)} onChange={(e) => handleNumQubitsChange(Number(e.target.value) || 1)} />
+            </label>
 
-        {/* Qubit Mapping (CompositeGate only) */}
-        {editingGate.type === "composite" && (
-          <div className="mb-2">
-            <h3 className="font-semibold mb-1">Qubit Mapping</h3>
-            {qubitMapping.map((q, i) => (
-              <div key={i} className="flex items-center gap-2 mb-1">
-                <label className="text-sm">{`Input ${i}:`}</label>
-                <select
-                  value={q}
-                  onChange={(e) => {
-                    const newQ = parseInt(e.target.value);
-                    setQubitMapping((prev) => {
-                      const copy = [...prev];
-                      copy[i] = newQ;
-                      return copy;
-                    });
-                  }}
-                  className="border rounded px-1 py-0.5 text-sm"
-                >
-                  {[...Array(totalQubits)].map((_, qi) => (
-                    <option key={qi} value={qi}>
-                      q[{qi}]
-                    </option>
-                  ))}
-                </select>
-              </div>
-            ))}
+            <div style={{ flex: 1 }} />
+
+            <label>
+              <span className="text-sm">Import CSV</span>
+              <input type="file" accept=".csv" onChange={handleImportCSV} />
+            </label>
           </div>
-        )}
 
-        {/* Matrix Editor */}
-        <div className="mb-2">
-          <span className="text-sm font-medium">Matrix Editor</span>
-          <div className="overflow-auto mt-2 border rounded-md p-2">
-            <table className="border-collapse">
-              <tbody>
-                {matrix.map((row, r) => (
-                  <tr key={r}>
-                    {row.map((val, c) => {
-                      const key = `${r}-${c}`;
-                      const invalid = invalidCells.has(key);
-                      return (
+          <div>
+            <span className="text-sm">Matrix</span>
+            <div className="overflow-auto mt-2 border rounded-md p-2">
+              <table className="border-collapse">
+                <tbody>
+                  {matrix.map((row, r) => (
+                    <tr key={r}>
+                      {row.map((cell, c) => (
                         <td key={c} className="p-1 border">
-                          <Input
-                            type="text"
-                            value={
-                              key in rawInputs
-                                ? rawInputs[key]
-                                : formatComplex(val)
-                            }
-                            onChange={(e) =>
-                              handleChangeMatrix(r, c, e.target.value)
-                            }
-                            onBlur={() => handleBlurMatrix(r, c)}
-                            className={`w-24 text-center font-mono ${
-                              invalid ? "border-red-500 bg-red-50" : ""
-                            }`}
-                          />
+                          <Input type="text" value={formatComplex(cell)} onChange={(e) => handleCellChange(r, c, e.target.value)} className="w-28 font-mono text-center" />
                         </td>
-                      );
-                    })}
-                  </tr>
-                ))}
-              </tbody>
-            </table>
+                      ))}
+                    </tr>
+                  ))}
+                </tbody>
+              </table>
+            </div>
+            {error && <div className="text-red-600 mt-1">{error}</div>}
           </div>
-        </div>
 
-        {/* Magnitude Preview */}
-        <div className="mb-2">
-          <span className="text-sm font-medium">Magnitude Preview</span>
-          <div
-            className="grid mt-2"
-            style={{ gridTemplateColumns: `repeat(${matrix.length}, 1fr)` }}
-          >
-            {matrix.flat().map((c, i) => (
-              <div
-                key={i}
-                className="w-6 h-6 m-0.5 rounded-sm"
-                style={{
-                  background: `rgba(79,70,229,${Math.min(1, Math.sqrt(c.re ** 2 + c.im ** 2))})`,
-                }}
-                title={`${c.re} + ${c.im}i`}
-              />
-            ))}
+          <div>
+            <span className="text-sm">Preview</span>
+            <div className="mt-2 p-2 border rounded-sm bg-white"><PreviewSVG /></div>
           </div>
-        </div>
 
-        {/* Footer */}
-        <div className="flex justify-end gap-2 mt-4">
-          <Button variant="outline" onClick={onCancel}>
-            Cancel
-          </Button>
-          <Button onClick={handleSave}>Save</Button>
+          <div className="flex justify-end gap-2 mt-4">
+            <Button variant="outline" onClick={() => { setEditingGate(null); onCancel(); }}>Cancel</Button>
+            <Button onClick={handleSave}>Save</Button>
+          </div>
         </div>
       </DialogContent>
     </Dialog>
diff --git a/frontend/src/state/useCircuitStore.ts b/frontend/src/state/useCircuitStore.ts
index ec0d8fd..4456294 100644
--- a/frontend/src/state/useCircuitStore.ts
+++ b/frontend/src/state/useCircuitStore.ts
@@ -1,10 +1,7 @@
 // src/state/useCircuitStore.ts
 import { create } from "zustand";
 
-export interface ComplexNumber {
-  re: number;
-  im: number;
-}
+export interface ComplexNumber { re: number; im: number; }
 
 export interface BaseGate {
   id: string;
@@ -16,16 +13,12 @@ export interface BaseGate {
   matrix: ComplexNumber[][];
 }
 
-export interface AtomicGate extends BaseGate {
-  type: "atomic";
-}
-
+export interface AtomicGate extends BaseGate { type: "atomic"; }
 export interface CompositeGate extends BaseGate {
   type: "composite";
   subCircuit: CircuitModel;
   qubitMapping?: number[];
 }
-
 export type GateModel = AtomicGate | CompositeGate;
 
 export interface CircuitModel {
@@ -49,10 +42,14 @@ interface CircuitState {
   bundles: QubitBundle[];
   editingGate?: GateModel | null;
 
+  // history (for option A snapshot undo/redo)
+  past: CircuitModel[];
+  future: CircuitModel[];
+
   // Basic ops
   addGate: (gate: GateModel) => void;
   removeGate: (id: string) => void;
-  updateGate: (id: string, updates: Partial<GateModel>) => void;
+  updateGate: (id: string, updates: Partial<GateModel> | GateModel) => void;
   duplicateGate: (id: string) => void;
   moveGatesTo: (ids: string[], column: number, qbitsForEach?: Record<string, number[]>) => void;
   setEditingGate: (gate: GateModel | null) => void;
@@ -76,18 +73,19 @@ interface CircuitState {
   // Persistence
   saveCircuit: () => void;
   loadCircuit: () => void;
+
+  // Undo/Redo (Option A â€” full snapshot)
+  undo: () => void;
+  redo: () => void;
+  clearHistory: () => void;
 }
 
 function generateIdentity(dim: number): ComplexNumber[][] {
   return Array.from({ length: dim }, (_, r) =>
-    Array.from({ length: dim }, (_, c) => ({
-      re: r === c ? 1 : 0,
-      im: 0,
-    }))
+    Array.from({ length: dim }, (_, c) => ({ re: r === c ? 1 : 0, im: 0 }))
   );
 }
 
-/** small helper to create an atomic identity gate for a given qbits length */
 function createIdentityAtomicGate(qbits: number[], column = 0): AtomicGate {
   const dim = 2 ** qbits.length;
   return {
@@ -101,191 +99,206 @@ function createIdentityAtomicGate(qbits: number[], column = 0): AtomicGate {
   };
 }
 
-export const useCircuitStore = create<CircuitState>((set, get) => ({
-  circuit: {
-    id: "root",
-    name: "root",
-    gates: [],
-    numQubits: 2,
-  },
-  selectedGateIds: [],
-  selectedQubits: [],
-  bundles: [],
-  editingGate: null,
-
-  addGate: (gate) =>
-    set((s) => ({
-      circuit: { ...s.circuit, gates: [...s.circuit.gates, gate] },
-    })),
-
-  removeGate: (id) =>
-    set((s) => ({
-      circuit: { ...s.circuit, gates: s.circuit.gates.filter((g) => g.id !== id) },
-    })),
-
-updateGate: (id, updates) =>
-  set((s) => {
-    const updatedGates = s.circuit.gates.map((g) => {
-      if (g.id !== id) return g;
-      const updated = { ...(g as any), ...(updates as Partial<typeof g>) } as GateModel;
-      return JSON.stringify(g) === JSON.stringify(updated) ? g : updated;
-    });
-    return { circuit: { ...s.circuit, gates: updatedGates } };
-  }),
+export const useCircuitStore = create<CircuitState>((set, get) => {
+  // helper to deep clone a circuit snapshot
+  const snapshot = (c: CircuitModel) => JSON.parse(JSON.stringify(c)) as CircuitModel;
 
-  duplicateGate: (id) =>
-    set((s) => {
-      const g = s.circuit.gates.find((x) => x.id === id);
-      if (!g) return s;
-      const dup = { ...g, id: crypto.randomUUID(), column: g.column + 1 };
-      return { circuit: { ...s.circuit, gates: [...s.circuit.gates, dup] } };
-    }),
-
-  moveGatesTo: (ids, column, qbitsForEach) =>
-    set((s) => ({
-      circuit: {
-        ...s.circuit,
-        gates: s.circuit.gates.map((g) =>
-          ids.includes(g.id)
-            ? { ...g, column, qbits: qbitsForEach?.[g.id] ?? g.qbits }
-            : g
-        ),
-      },
-    })),
-
-  setEditingGate: (gate) => set({ editingGate: gate }),
-  setSelectedGates: (ids) => set({ selectedGateIds: ids }),
-
-  addQubit: () =>
-    set((s) => ({
-      circuit: { ...s.circuit, numQubits: s.circuit.numQubits + 1 },
-    })),
-
-  removeQubit: () =>
+  // helper that records current circuit to past, clears future, and applies change
+  const applyWithSnapshot = (changer: (s: CircuitState) => Partial<CircuitState>) =>
     set((s) => {
-      const newCount = Math.max(1, s.circuit.numQubits - 1);
+      const before = snapshot(s.circuit);
+      const changes = changer(s) || {};
       return {
+        ...changes,
+        past: [...s.past, before],
+        future: [],
+      } as Partial<CircuitState> as CircuitState;
+    });
+
+  return {
+    // initial app state
+    circuit: { id: "root", name: "root", gates: [], numQubits: 2 },
+    selectedGateIds: [],
+    selectedQubits: [],
+    bundles: [],
+    editingGate: null,
+    past: [],
+    future: [],
+
+    /* ---------------- basic ops ---------------- */
+    addGate: (gate) =>
+      applyWithSnapshot((s) => ({ circuit: { ...s.circuit, gates: [...s.circuit.gates, gate] } })),
+
+    removeGate: (id) =>
+      applyWithSnapshot((s) => ({ circuit: { ...s.circuit, gates: s.circuit.gates.filter((g) => g.id !== id) } })),
+
+    updateGate: (id, updates) =>
+      applyWithSnapshot((s) => {
+        const updatedGates = s.circuit.gates.map((g) => {
+          if (g.id !== id) return g;
+          // If updates looks like a full GateModel (has matrix and qbits) replace entirely,
+          // otherwise shallow merge partials.
+          const maybeFull = updates as GateModel;
+          if ((maybeFull as GateModel).matrix !== undefined && (maybeFull as GateModel).qbits !== undefined) {
+            return { ...(maybeFull as GateModel) };
+          } else {
+            return { ...(g as any), ...(updates as Partial<typeof g>) } as GateModel;
+          }
+        });
+        return { circuit: { ...s.circuit, gates: updatedGates } };
+      }),
+
+    duplicateGate: (id) =>
+      applyWithSnapshot((s) => {
+        const g = s.circuit.gates.find((x) => x.id === id);
+        if (!g) return {};
+        const dup = { ...g, id: crypto.randomUUID(), column: (g.column ?? 0) + 1 };
+        return { circuit: { ...s.circuit, gates: [...s.circuit.gates, dup] } };
+      }),
+
+    moveGatesTo: (ids, column, qbitsForEach) =>
+      applyWithSnapshot((s) => ({
         circuit: {
           ...s.circuit,
-          numQubits: newCount,
-          gates: s.circuit.gates.filter((g) => g.qbits.every((q) => q < newCount)),
+          gates: s.circuit.gates.map((g) =>
+            ids.includes(g.id)
+              ? { ...g, column, qbits: qbitsForEach?.[g.id] ?? g.qbits }
+              : g
+          ),
         },
-      };
-    }),
-
-  /***************
-   * Grouping
-   ***************/
-  groupSelectedGates: () =>
-    set((s) => {
-      const ids = s.selectedGateIds;
-      if (ids.length < 2) return s; // nothing to group
-
-      const selected = s.circuit.gates.filter((g) => ids.includes(g.id));
-      const remaining = s.circuit.gates.filter((g) => !ids.includes(g.id));
-
-      // Determine bounds for placement
-      const minColumn = Math.min(...selected.map((g) => g.column));
-      const involvedQubits = Array.from(
-        new Set(selected.flatMap((g) => g.qbits))
-      ).sort((a, b) => a - b);
-
-      // Create the subcircuit object (id & name must be strings)
-      const subCircuit: CircuitModel = {
-        id: crypto.randomUUID(),
-        name: `subcircuit-${Date.now()}`,
-        gates: selected.map((g) => ({ ...g } as GateModel)),
-        numQubits: involvedQubits.length,
-      };
-
-      // Composite gate needs a matrix (we use identity placeholder â€” you can optionally compute reduction)
-      const compositeMatrix = generateIdentity(2 ** involvedQubits.length);
-
-      const compositeGate: CompositeGate = {
-        id: crypto.randomUUID(),
-        type: "composite",
-        name: `Group ${Date.now()}`,
-        symbol: "G",
-        column: minColumn,
-        qbits: involvedQubits,
-        matrix: compositeMatrix,
-        subCircuit,
-        qubitMapping: involvedQubits.slice(),
-      };
-
-      return {
-        circuit: { ...s.circuit, gates: [...remaining, compositeGate] },
-        selectedGateIds: [],
-      };
-    }),
-
-  /***************
-   * Ungrouping
-   ***************/
-  ungroupCompositeGate: (id) =>
-    set((s) => {
-      const target = s.circuit.gates.find(
-        (g): g is CompositeGate => g.id === id && g.type === "composite"
-      );
-      if (!target) return s;
-
-      const remaining = s.circuit.gates.filter((g) => g.id !== id);
-
-      // Map subcircuit gates to parent qubits
-      const expanded: GateModel[] = target.subCircuit.gates.map((g) => {
-        const mappedQbits = g.qbits.map((q) => {
-          // map subcircuit q index -> parent qbit using qubitMapping if present
-          return target.qubitMapping?.[q] ?? target.qbits[q] ?? q;
+      })),
+
+    setEditingGate: (gate) => set({ editingGate: gate }),
+    setSelectedGates: (ids) => set({ selectedGateIds: ids }),
+
+    /* ---------------- qubits ---------------- */
+    addQubit: () =>
+      applyWithSnapshot((s) => ({ circuit: { ...s.circuit, numQubits: s.circuit.numQubits + 1 } })),
+
+    removeQubit: () =>
+      applyWithSnapshot((s) => {
+        const newCount = Math.max(1, s.circuit.numQubits - 1);
+        return {
+          circuit: {
+            ...s.circuit,
+            numQubits: newCount,
+            gates: s.circuit.gates.filter((g) => g.qbits.every((q) => q < newCount)),
+          },
+        };
+      }),
+
+    /* ------------- grouping / composite ------------- */
+    groupSelectedGates: () =>
+      applyWithSnapshot((s) => {
+        const ids = s.selectedGateIds;
+        if (ids.length < 2) return {};
+        const selected = s.circuit.gates.filter((g) => ids.includes(g.id));
+        const remaining = s.circuit.gates.filter((g) => !ids.includes(g.id));
+        const minColumn = Math.min(...selected.map((g) => g.column));
+        const involvedQubits = Array.from(new Set(selected.flatMap((g) => g.qbits))).sort((a, b) => a - b);
+
+        const subCircuit: CircuitModel = {
+          id: crypto.randomUUID(),
+          name: `subcircuit-${Date.now()}`,
+          gates: selected.map((g) => ({ ...g } as GateModel)),
+          numQubits: involvedQubits.length,
+        };
+
+        const compositeMatrix = generateIdentity(2 ** involvedQubits.length);
+
+        const compositeGate: CompositeGate = {
+          id: crypto.randomUUID(),
+          type: "composite",
+          name: `Group ${Date.now()}`,
+          symbol: "G",
+          column: minColumn,
+          qbits: involvedQubits,
+          matrix: compositeMatrix,
+          subCircuit,
+          qubitMapping: involvedQubits.slice(),
+        };
+
+        return {
+          circuit: { ...s.circuit, gates: [...remaining, compositeGate] },
+          selectedGateIds: [],
+        };
+      }),
+
+    ungroupCompositeGate: (id) =>
+      applyWithSnapshot((s) => {
+        const target = s.circuit.gates.find((g): g is CompositeGate => g.id === id && g.type === "composite");
+        if (!target) return {};
+        const remaining = s.circuit.gates.filter((g) => g.id !== id);
+        const expanded: GateModel[] = target.subCircuit.gates.map((g) => {
+          const mappedQbits = g.qbits.map((q) => target.qubitMapping?.[q] ?? target.qbits[q] ?? q);
+          return { ...(g as any), id: crypto.randomUUID(), column: target.column + (g.column ?? 0), qbits: mappedQbits } as GateModel;
         });
-        return { ...(g as any), id: crypto.randomUUID(), column: target.column + (g.column ?? 0), qbits: mappedQbits } as GateModel;
-      });
-
-      return {
-        circuit: { ...s.circuit, gates: [...remaining, ...expanded] },
-      };
-    }),
-  
-  /***************
-   * Qubits
-   ***************/  
-  setSelectedQubits: (ids) => set({ selectedQubits: ids }),
-  toggleSelectQubit: (q, multi) =>
-    set((s) => {
-      const cur = new Set(s.selectedQubits);
-      if (multi) {
-        if (cur.has(q)) cur.delete(q);
-        else cur.add(q);
-      } else {
-        // replace
-        cur.clear();
-        cur.add(q);
+        return { circuit: { ...s.circuit, gates: [...remaining, ...expanded] } };
+      }),
+
+    /* ------------- qubit bundles ------------- */
+    setSelectedQubits: (ids) => set({ selectedQubits: ids }),
+    toggleSelectQubit: (q, multi) =>
+      set((s) => {
+        const cur = new Set(s.selectedQubits);
+        if (multi) {
+          if (cur.has(q)) cur.delete(q);
+          else cur.add(q);
+        } else {
+          cur.clear();
+          cur.add(q);
+        }
+        return { selectedQubits: Array.from(cur) };
+      }),
+    clearSelectedQubits: () => set({ selectedQubits: [] }),
+
+    createQubitBundle: (name, qbits, color) =>
+      applyWithSnapshot((s) => {
+        const id = crypto.randomUUID();
+        const bundle: QubitBundle = { id, name, qbits: [...qbits].sort((a, b) => a - b), color };
+        return { bundles: [...s.bundles, bundle] };
+      }),
+
+    removeQubitBundle: (id) =>
+      applyWithSnapshot((s) => ({ bundles: s.bundles.filter((b) => b.id !== id) })),
+
+    /* ------------- persistence ------------- */
+    saveCircuit: () => {
+      const { circuit } = get();
+      localStorage.setItem("circuit", JSON.stringify(circuit));
+    },
+
+    loadCircuit: () => {
+      const data = localStorage.getItem("circuit");
+      if (!data) return;
+      try {
+        const parsed = JSON.parse(data) as CircuitModel;
+        // loading a circuit is a snapshot-worthy action
+        applyWithSnapshot(() => ({ circuit: parsed }));
+      } catch {
+        // noop
       }
-      return { selectedQubits: Array.from(cur) };
-    }),
-  
-  clearSelectedQubits: () => set({ selectedQubits: [] }),
-  createQubitBundle: (name, qbits, color) =>
-    set((s) => {
-      const id = crypto.randomUUID();
-      const bundle = { id, name, qbits, color };
-      return { bundles: [...(s.bundles ?? []), bundle] };
-    }),
-  removeQubitBundle: (id) =>
-    set((s) => ({ bundles: (s.bundles ?? []).filter((b) => b.id !== id) })),
-
-
-  /***************
-   * Persistence
-   ***************/
-  saveCircuit: () => {
-    const { circuit } = get();
-    localStorage.setItem("circuit", JSON.stringify(circuit));
-  },
-
-  loadCircuit: () => {
-    const data = localStorage.getItem("circuit");
-    if (!data) return;
-    const parsed = JSON.parse(data) as CircuitModel;
-    set({ circuit: parsed });
-  },
-}));
+    },
+
+    /* ------------- undo / redo (Option A â€” snapshots) ------------- */
+    undo: () =>
+      set((s) => {
+        if (!s.past?.length) return s;
+        const prev = s.past[s.past.length - 1];
+        const newPast = s.past.slice(0, -1);
+        const newFuture = [snapshot(s.circuit), ...(s.future ?? [])];
+        return { circuit: snapshot(prev), past: newPast, future: newFuture } as Partial<CircuitState> as CircuitState;
+      }),
+
+    redo: () =>
+      set((s) => {
+        if (!s.future?.length) return s;
+        const next = s.future[0];
+        const newFuture = s.future.slice(1);
+        const newPast = [...(s.past ?? []), snapshot(s.circuit)];
+        return { circuit: snapshot(next), past: newPast, future: newFuture } as Partial<CircuitState> as CircuitState;
+      }),
+
+    clearHistory: () => set((s) => ({ past: [], future: [] })),
+  };
+});
